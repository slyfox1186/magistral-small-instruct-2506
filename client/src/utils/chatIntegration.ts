import { crudApi } from '@/api/crud';
import { AppMessage } from '@/utils/messageUtils';
import { logger } from '@/utils';

/**
 * Integration service to automatically manage conversations and messages
 * when using the traditional chat interface
 */
class ChatIntegrationService {
  private currentConversationId: string | null = null;
  private sessionId: string | null = null;

  /**
   * Initialize or get existing conversation for the current session
   */
  async initializeConversation(sessionId: string, firstMessage?: string): Promise<string | null> {
    try {
      this.sessionId = sessionId;
      
      // Check if we already have a conversation for this session
      if (this.currentConversationId) {
        return this.currentConversationId;
      }

      // Try to find existing conversation by session metadata
      const conversations = await crudApi.listConversations(1, 50);
      const existingConversation = conversations.conversations.find(
        (conv: { metadata?: Record<string, unknown>; archived: boolean }) => conv.metadata?.sessionId === sessionId && !conv.archived
      );

      if (existingConversation) {
        this.currentConversationId = existingConversation.id;
        return this.currentConversationId;
      }

      // Create new conversation
      const title = firstMessage 
        ? this.generateTitleFromMessage(firstMessage)
        : `Chat Session ${new Date().toLocaleDateString()}`;

      const newConversation = await crudApi.createConversation({
        title,
        tags: ['auto-generated', 'chat-session'],
        metadata: {
          sessionId,
          autoGenerated: true,
          createdFromChat: true,
        }
      });

      this.currentConversationId = newConversation.id;
      logger.info('Created new conversation for chat session:', newConversation.id);
      
      return this.currentConversationId;
    } catch (error) {
      logger.error('Failed to initialize conversation:', error);
      return null;
    }
  }

  /**
   * Save a message to the current conversation
   */
  async saveMessage(message: AppMessage): Promise<boolean> {
    try {
      if (!this.currentConversationId) {
        logger.warn('No conversation initialized, cannot save message');
        return false;
      }

      await crudApi.createMessage({
        conversation_id: this.currentConversationId,
        role: message.role,
        content: message.content,
        metadata: {
          messageId: message.id,
          timestamp: new Date().toISOString(),
          fromChatInterface: true,
        }
      });

      logger.debug('Saved message to conversation:', message.id);
      return true;
    } catch (error) {
      logger.error('Failed to save message:', error);
      return false;
    }
  }

  /**
   * Save multiple messages (for bulk operations like loading from localStorage)
   */
  async saveMessages(messages: AppMessage[]): Promise<number> {
    if (!this.currentConversationId) {
      logger.warn('No conversation initialized, cannot save messages');
      return 0;
    }

    let savedCount = 0;
    for (const message of messages) {
      const success = await this.saveMessage(message);
      if (success) savedCount++;
    }

    logger.info(`Saved ${savedCount}/${messages.length} messages to conversation`);
    return savedCount;
  }

  /**
   * Update conversation title based on chat content
   */
  async updateConversationTitle(newTitle: string): Promise<boolean> {
    try {
      if (!this.currentConversationId) {
        return false;
      }

      await crudApi.updateConversation(this.currentConversationId, {
        title: newTitle,
        metadata: {
          sessionId: this.sessionId,
          autoGenerated: true,
          createdFromChat: true,
          titleUpdated: true,
        }
      });

      return true;
    } catch (error) {
      logger.error('Failed to update conversation title:', error);
      return false;
    }
  }

  /**
   * Get current conversation ID
   */
  getCurrentConversationId(): string | null {
    return this.currentConversationId;
  }

  /**
   * Clear current conversation (for new sessions)
   */
  clearConversation(): void {
    this.currentConversationId = null;
    this.sessionId = null;
  }

  /**
   * Generate a meaningful title from the first message
   */
  private generateTitleFromMessage(message: string): string {
    // Clean and truncate the message
    const cleaned = message.trim().replace(/\n+/g, ' ').substring(0, 100);
    
    // If it's a question, use it as is
    if (cleaned.includes('?')) {
      return cleaned.length > 50 ? cleaned.substring(0, 47) + '...' : cleaned;
    }
    
    // If it's a command or instruction, extract the key part
    const commandPatterns = [
      /^(help|explain|tell me|show me|how do|what is|create|build|make)\s+(.+)/i,
      /^(please|can you|could you)\s+(.+)/i,
    ];

    for (const pattern of commandPatterns) {
      const match = cleaned.match(pattern);
      if (match && match[2]) {
        const extracted = match[2].trim();
        return extracted.length > 50 ? extracted.substring(0, 47) + '...' : extracted;
      }
    }

    // Default: use first 50 characters
    return cleaned.length > 50 ? cleaned.substring(0, 47) + '...' : cleaned;
  }

  /**
   * Auto-generate conversation title from recent messages
   */
  async autoUpdateTitle(messages: AppMessage[]): Promise<void> {
    if (!this.currentConversationId || messages.length < 2) {
      return;
    }

    try {
      // Find the first user message
      const firstUserMessage = messages.find(m => m.role === 'user');
      if (firstUserMessage) {
        const newTitle = this.generateTitleFromMessage(firstUserMessage.content);
        await this.updateConversationTitle(newTitle);
      }
    } catch (error) {
      logger.error('Failed to auto-update conversation title:', error);
    }
  }

  /**
   * Archive current conversation
   */
  async archiveCurrentConversation(): Promise<boolean> {
    try {
      if (!this.currentConversationId) {
        return false;
      }

      await crudApi.archiveConversation(this.currentConversationId);
      this.clearConversation();
      return true;
    } catch (error) {
      logger.error('Failed to archive conversation:', error);
      return false;
    }
  }
}

// Export singleton instance
export const chatIntegration = new ChatIntegrationService();
export default chatIntegration;